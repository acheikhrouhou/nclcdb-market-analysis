here’s a tight, “ready-to-build” spec for **api.nclcdbaas.com** covering the tech stack, architecture, security model, and the API interface/usage (CRUD only, base-scoped, no DDL/billing).

---

# Stack & Architecture (production-minded)

**Gateway & Edge**

* **Cloud CDN/WAF**: Cloudflare or AWS CloudFront + WAF (DDoS, bot, TLS, IP allowlist for admin/testing).
* **API Gateway/Proxy**: **Envoy** or **NGINX** (mTLS to backend, timeouts/retries, gzip, HTTP/2, HSTS).
* **Rate limiter**: **Redis** (sliding window/leaky bucket) keyed by `{token_id}:{route}`.

**Application Layer**

* Runtime: **TypeScript + Fastify** (or **NestJS**) *or* **Go (Fiber/Chi)**.
* AuthN/Z middleware (token verify, scope check).
* Request validation: **Zod** (TS) or **OAPI generator** from OpenAPI.
* Background jobs (async webhooks, metering): **BullMQ** (Redis) or **SQS**.

**Database Access**

* **PostgreSQL** (managed), **pgx/pg** client, **PgBouncer** for pooling.
* Per-base connection routing via Control Plane lookup (token→base mapping cache).
* **RLS enabled** if you later add per-row scoping; tenant isolation via base-level DB.

**Observability**

* **OpenTelemetry** (traces/metrics) → Grafana/Tempo/Prometheus.
* **Structured logs** (JSON) → Loki/ELK; request_id correlation.
* **Sentry** for error tracking.

**Schema & Docs**

* **OpenAPI 3.1** source of truth → rendered via **Redoc** / Swagger UI.
* SDKs generated (TypeScript, Python).

---

# Security Model (simple, strict)

* **Base-scoped tokens**: Each API token is valid for **exactly one base** and has **scopes**: `read`, `write`, `delete`.
* **Authorization header**: `Authorization: Bearer <opaque_token>` (stored hashed server-side).
* **Mandatory headers**:

  * `X-Base-Id: <uuid>` *(optional if token embeds base_id; recommended to require for defense-in-depth)*
  * `X-Idempotency-Key: <uuid>` *(for POST/PATCH batch; optional but recommended)*
* **CORS**: allow only `https://app.nclcdbaas.com` (and customer domains when enabled).
* **Principle of least privilege**: the API service role has **no DDL**; CRUD only on `data.*` tables of that base.
* **Row-level security**: off by default (tenant-level isolation via base routing). Can be enabled per table later.
* **Rate limits**: default 600 req/min per token; 429 with `Retry-After`.
* **Quotas**: `api_calls` metered; **automation runs** are debited elsewhere (not in this CRUD API).

---

# Resource Model (simple by design)

* **Table identity**: by **system name** or **table UUID**.

  * Paths accept either: `{tableId}` can be a UUID or a URL-safe name.
* **Record identity**: `id` (UUID) per row, generated by server unless client supplies a valid UUID.
* **Fields**: dynamic per table; values must conform to types defined in `runtime_meta.fields`.

---

# Base URL & Versioning

* **Base**: `https://api.nclcdbaas.com/v1`
* Versioning policy: additive, backward-compatible. Breaking changes via `/v2` with deprecation window.
* **OpenAPI** at `GET /v1/openapi.json` and Docs viewer at `https://www.nclcdbaas.com/docs/api`.

---

# Endpoints (CRUD only)

> All endpoints require `Authorization: Bearer <token>` and either an embedded base in token or `X-Base-Id`.

### Records (collection)

```
GET    /v1/tables/{tableId}/records
POST   /v1/tables/{tableId}/records
DELETE /v1/tables/{tableId}/records   (bulk by filter or ids[])
```

### Record (single)

```
GET    /v1/tables/{tableId}/records/{id}
PATCH  /v1/tables/{tableId}/records/{id}
DELETE /v1/tables/{tableId}/records/{id}
```

### Batch operations (atomic per request)

```
POST   /v1/tables/{tableId}/records:batchUpsert      (by unique field or id)
POST   /v1/tables/{tableId}/records:batchDelete
```

### Utilities

```
POST   /v1/tables/{tableId}/import:csv               (pre-signed URL flow)
GET    /v1/tables/{tableId}/export:csv               (async, returns job & signed URL)
POST   /v1/files:signUpload                           (get signed URL for attachments)
```

---

# Querying (filters, sort, pagination)

**Pagination (cursor)**

* Request: `limit` (1–1000, default 100), `cursor` (opaque).
* Response: `next_cursor`, `has_more`.

**Filters**

* Simple operators via query:

  * `filter[name][eq]=Acme`
  * `filter[amount][gt]=100`
  * `filter[status][in]=open,closed`
  * `filter[created_at][between]=2025-01-01,2025-01-31`
* Complex where clauses (optional): `where` as JSON (whitelisted ops only).

**Sort**

* `sort=created_at.desc,name.asc`

**Projection**

* `fields=name,email,amount` (only return subset to reduce payload).

---

# Request / Response shapes

### List records

**GET** `/v1/tables/customers/records?limit=2&sort=created_at.desc`

```json
{
  "data": [
    {
      "id": "2d9f1f7a-9f3d-4f3e-9b2e-7a8a55c7d4a1",
      "name": "Acme Corp",
      "email": "ops@acme.com",
      "created_at": "2025-10-01T12:34:56Z",
      "updated_at": "2025-10-02T09:10:11Z"
    },
    {
      "id": "5f6e3f0e-7339-4b67-94b2-0e2e3e5b7c12",
      "name": "Globex",
      "email": "it@globex.com",
      "created_at": "2025-10-01T08:00:00Z",
      "updated_at": "2025-10-01T08:00:00Z"
    }
  ],
  "next_cursor": "eyJvZmZzZXQiOjJ9",
  "has_more": true
}
```

### Create record

**POST** `/v1/tables/customers/records`
Headers: `X-Idempotency-Key: 9b6d...`

```json
{
  "values": {
    "name": "Initech",
    "email": "contact@initech.com",
    "status": "active"
  }
}
```

**201 Created**

```json
{
  "id": "3ca3dfad-2a40-4d1a-a9e1-0dca1d4fcd25",
  "values": {
    "name": "Initech",
    "email": "contact@initech.com",
    "status": "active"
  },
  "created_at": "2025-10-27T12:01:12Z",
  "updated_at": "2025-10-27T12:01:12Z"
}
```

### Update record (partial)

**PATCH** `/v1/tables/customers/records/3ca3dfad-...`

```json
{ "values": { "status": "churned" } }
```

**200 OK** returns merged record.

### Batch upsert

**POST** `/v1/tables/customers/records:batchUpsert?unique=email`

```json
{
  "items": [
    { "values": { "email": "a@acme.com", "name": "Alice" } },
    { "values": { "email": "b@acme.com", "name": "Bob" } }
  ]
}
```

**200 OK**

```json
{
  "upserted": 2,
  "ids": ["...","..."],
  "job_id": null
}
```

### Bulk delete by ids

**POST** `/v1/tables/customers/records:batchDelete`

```json
{ "ids": ["id-1","id-2","id-3"] }
```

### Delete by filter (guarded)

**DELETE** `/v1/tables/logs/records?filter[created_at][lt]=2025-01-01`

* Requires header `X-Allow-Filtered-Delete: true` to avoid accidents.
* Responds with `{ "deleted": 123 }`.

---

# Errors (uniform, debuggable)

* Status codes: `400, 401, 403, 404, 409, 413, 422, 429, 500`.
* Body:

```json
{
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Field 'email' must be a valid email.",
    "details": { "field": "email" }
  },
  "request_id": "req_01H..."
}
```

Common codes:

* `AUTH_REQUIRED`, `INVALID_TOKEN`, `INSUFFICIENT_SCOPE`
* `TABLE_NOT_FOUND`, `RECORD_NOT_FOUND`
* `RATE_LIMITED`
* `IDEMPOTENCY_REPLAYED`
* `PAYLOAD_TOO_LARGE` (413) for big batches; suggest CSV import

---

# Idempotency & Concurrency

* **Idempotency**: `X-Idempotency-Key` deduplicates POST/batch for 24h (stored in Redis with response cache).
* **Optimistic concurrency**: support `If-Match` with record `etag` (hash of values/updated_at) to avoid lost updates. Returns `412 Precondition Failed` on mismatch.

---

# Attachments

1. Client requests signed URL:

   * **POST** `/v1/files:signUpload` → `{ url, fields, key, expires_at }`.
2. Client uploads directly to S3/GCS.
3. Client sets record field with uploaded `attachment` descriptor:

```json
{ "values": { "files": [ { "id":"att_x", "key":"s3://...", "name":"a.pdf", "size":12345, "mime":"application/pdf" } ] } }
```

---

# Webhooks (optional now, useful soon)

* Register delivery endpoints in the portal; API posts JSON for events:

  * `record.created`, `record.updated`, `record.deleted`
* Retry with exponential backoff; HMAC signature header (`X-Signature: sha256=...`).

---

# SDKs (recommended surface)

* `client.records.list({ table, filter, sort, limit, cursor })`
* `client.records.create({ table, values })`
* `client.records.update({ table, id, values })`
* `client.records.batchUpsert({ table, items, unique })`
* `client.files.signUpload({ filename, mime, size })`

Generated from OpenAPI; publish on npm/PyPI.

---

# Deployment & Ops

* **Cold start SLA**: < 500ms P95 behind CDN.
* **Latency goals**: P95 list/read < 200ms; write < 350ms.
* **Throughput**: use PgBouncer + per-base pool constraints to avoid noisy-neighbor issues.
* **Token cache**: LRU w/ 60s TTL; hard validate if scopes/tenant mismatches suspected.
* **Metering**: async—fire-and-forget to the metering queue; don’t block user path.

---

# cURL quickstart (copy/paste)

```bash
# List (first 2)
curl -s https://api.nclcdbaas.com/v1/tables/customers/records \
  -H "Authorization: Bearer $API_TOKEN" \
  -H "X-Base-Id: $BASE_ID" \
  -G --data-urlencode "limit=2" --data-urlencode "sort=created_at.desc"

# Create
curl -s -X POST https://api.nclcdbaas.com/v1/tables/customers/records \
  -H "Authorization: Bearer $API_TOKEN" \
  -H "X-Base-Id: $BASE_ID" \
  -H "Content-Type: application/json" \
  -H "X-Idempotency-Key: $(uuidgen)" \
  -d '{"values":{"name":"Initech","email":"contact@initech.com"}}'
```

---

## TL;DR

* **Tech**: Cloudflare/WAF → Envoy → Fastify/NestJS (TS) → Postgres (PgBouncer), Redis for rate limit/idempotency, OTel/Sentry for ops.
* **Security**: base-scoped tokens, scopes, strict CORS, no DDL/billing exposure.
* **API**: `/v1/tables/{table}/records` CRUD, cursor pagination, rich filters/sorts, batch upsert, idempotency.
* **Docs/SDKs**: OpenAPI-driven, consistent error model, examples included.

If you want, I can turn this into a **machine-readable OpenAPI 3.1 draft** you can drop into a docs viewer and start generating SDKs from.
